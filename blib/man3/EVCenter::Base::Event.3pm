.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "EVCenter::Base::Event 3"
.TH EVCenter::Base::Event 3 "2015-07-15" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVCenter::Base::Event
.SH "VERSION"
.IX Header "VERSION"
This documentation refers to EVCenter::Base::Event version 0.1
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use EVCenter::Base::Event;
\&
\&    my $ev = EVCenter::Base::Event\->new( 
\&                                    dbhost => \*(AqIP/Hostname of DB Server\*(Aq,
\&                                    dbname => \*(AqDatabase Name\*(Aq,
\&                                    dbuser => \*(AqDatabase User\*(Aq,
\&                                    dbpass => \*(AqDatabase Password\*(Aq,
\&                                    dbport => \*(AqDatabase Port\*(Aq,
\&                                    dbopts => \*(AqDatabase Options (see DBD::Pg opts)\*(Aq,
\&                                    dbi_opts => { }, # DBI specific options, such as AutoCommit
\&              );
\&
\&    my $inserted_count = $ev\->add_events( \e@event_list );
\&    my $deleted_count  = $ev\->del_events( filter => \e%filter, restrict => \e%restrict_filter );
\&    my $events_hashref = $ev\->get_events( filter => \e%filter, restrict => \e%restrict_filter );
\&    my $updated_count  = $ev\->upd_events( update => \e%data, filter => \e%filter, restrict => \e%restrict_filter );
\&    print $ev\->errstr if ($ev\->errstr);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is the base for EVCenter access to the Events database. It connects to the database with the
credentials provided and provides basic methods to insert, delete or return events.
.SH "METHODS"
.IX Header "METHODS"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Returns a new object.
.PP
\fI\f(CI\*(C`add_events\*(C'\fI\fR
.IX Subsection "add_events"
.PP
\fI\f(CI\*(C`del_events\*(C'\fI\fR
.IX Subsection "del_events"
.PP
.Vb 1
\&    my $deleted = $ev\->del_events( filter => \e%filter, restrict => \e%restrict_filter );
\&
\&    Delete the rows that matches filter AND restrict filters. Returns the number of deleted events
\&    or undef on failure.
.Ve
.PP
\fI\f(CI\*(C`get_events\*(C'\fI\fR
.IX Subsection "get_events"
.PP
.Vb 1
\&    my $events_hashref = $ev\->get_events( filter => \e%filter, restrict => \e%restrict_filter );
\&
\&    Returns the events that matches both filter AND restrict. The events are returned as a hash reference
\&    with the serial number of the event as the key.
\&
\&    Returns undef on failure.
.Ve
.PP
\fI\f(CI\*(C`upd_events\*(C'\fI\fR
.IX Subsection "upd_events"
.PP
.Vb 1
\&    my $updated_count = $ev\->upd_events( update => \e%data, filter => \e%filter, restrict => \e%restrict_filter );
\&
\&    Updates the events that match filter AND restrict, setting up the column in update key.
\&
\&    Returns the number of updated rows of undef on failure.
.Ve
.PP
\fI\f(CI\*(C`filter\*(C'\fI \- \f(CI\*(C`restrict\*(C'\fI \- \f(CI\*(C`update\*(C'\fI \s-1FORMAT\s0\fR
.IX Subsection "filter - restrict - update FORMAT"
.PP
.Vb 1
\&    All these values respect SQL::Abstract notation (http://search.cpan.org/~ribasushi/SQL\-Abstract\-1.74/lib/SQL/Abstract.pm)
\&
\&    \*(Aqrestrict\*(Aq is intended to provide a master filter, when it\*(Aqs needed to restrict the user access to only a group
\&    of events. \*(Aqrestrict\*(Aq will always be ANDed to the current filter.
\&
\&    Examples:
\&
\&    update = {
\&        suppression => 1,
\&        message     => \*(AqFailure on module #1\*(Aq
\&    };
\&
\&    restrict = {
\&        node => { like => \*(Aq%CTA%\*(Aq }
\&    };
\&
\&    filter = {
\&        serial => [ 1024, 1025 ];
\&    };
\&
\&    filter = {
\&        node   => [ \*(AqSVLXGER1\*(Aq ],
\&        object => [ \*(AqETH1\*(Aq ]
\&    }
.Ve
.PP
\fI\f(CI\*(C`errstr\*(C'\fI\fR
.IX Subsection "errstr"
.PP
\&\f(CW$ev\fR\->errstr
.PP
Gets the last Error String generated. All methods reset this value when called.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
There are no known bugs in this module.
Please report problems to Joao Andre Simioni <jasimioni@gmail.com>
.SH "AUTHOR"
.IX Header "AUTHOR"
Joao Andre Simioni <jasimioni@gmail.com>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2013 Joao Andre Simioni (<jasimioni@gmail.com>). All rights reserved.
.PP
This module is not free software; you cannot use, redistribute it or do anything
without explicit authorization from the author.
